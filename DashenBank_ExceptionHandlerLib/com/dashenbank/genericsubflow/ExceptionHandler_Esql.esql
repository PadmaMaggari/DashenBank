



BROKER SCHEMA com.dashenbank.genericsubflow
PATH com.dashenbank.genericfunctions;
DECLARE LOG4J_CONFIG_PATH EXTERNAL CHARACTER '';
DECLARE LOG4J_ERROR_MSG EXTERNAL CHARACTER '';
DECLARE LOGGER_NAME EXTERNAL CHARACTER '';
DECLARE LOG_TYPE EXTERNAL CHARACTER '';
DECLARE TIMEOUT_ERROR_MSG EXTERNAL CHARACTER '';
DECLARE rc BOOLEAN FALSE;
CREATE COMPUTE MODULE ExceptionHandler_Esql
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		CALL initLog4j(LOG4J_CONFIG_PATH) INTO rc;
		IF ( rc = FALSE ) THEN
			SET Environment.Variables.Log4j.ErrorMsg = LOG4J_ERROR_MSG;
		END IF;
		CALL writeToLogFile(MessageFlowLabel, LOGGER_NAME, LOG_TYPE,'..............start logging Exception...........') INTO rc;
		DECLARE exceptiondesc,inputChar,logdata CHARACTER '';
		DECLARE inRef REFERENCE TO InputRoot;
		DECLARE domainDataRef REFERENCE TO InputBody;
		DECLARE domainName CHARACTER FIELDNAME(InputBody);
		DECLARE ccsID INTEGER InputRoot.Properties.CodedCharSetId;
		DECLARE encodeID INTEGER InputRoot.Properties.Encoding;
		--SET Environment.REQUEST_PAYLOAD = getPayLoad(domainName,domainDataRef,encodeID,ccsID);
		--set input properties in environment
		SET Environment.Properties = InputRoot.Properties;
		SET OutputRoot.Properties = InputRoot.Properties;
		SET Environment.Variables.RequestIdentifier = InputLocalEnvironment.Destination.HTTP.RequestIdentifier;
		DECLARE inExcpRef REFERENCE TO InputExceptionList.*[1];
		--DECLARE flowName CHARACTER inExcpRef.Name;
		IF EXISTS(InputExceptionList.*[]) THEN
			DECLARE insertRef REFERENCE TO InputExceptionList.*[1];
			DECLARE domainName CHAR 'XMLNSC';
			DECLARE outRef REFERENCE TO Environment;
			--get exception in xml format
			CALL getExceptionDesc(inExcpRef,insertRef,outRef,domainName);
			--copying exception details in environment
			DECLARE envRef REFERENCE TO Environment.XMLNSC.ExceptionDetails;
			DECLARE excpPayload CHARACTER getPayLoad(domainName,domainDataRef,encodeID,ccsID);
			CREATE LASTCHILD OF OutputRoot AS outRef DOMAIN 'XMLNSC';
			CREATE LASTCHILD OF outRef AS outRef NAMESPACE 'soapenv' NAME 'Envelope';
			CREATE LASTCHILD OF outRef AS outRef NAMESPACE 'soapenv' NAME 'Body';
			CREATE LASTCHILD OF outRef AS outRef NAMESPACE 'esb' NAME envRef.ServiceName;
			CALL BuildExceptionDetails(envRef,outRef,envRef.ServiceName);
			------------Error Logging in DB----------
			CALL INSERT_ERROR_AUDIT_LOGS(CURRENT_TIMESTAMP,'ACE_USER',outRef.ErrorType,envRef.FlowName,envRef.ApplicationName,ExecutionGroupLabel,
			excpPayload,Environment.REQUEST_PAYLOAD,outRef.excpNumber,outRef.ErrorCode);
			-------------------------------------------
			SET Environment.Variables.ExceptionDetails = OutputRoot.XMLNSC.ExceptionDetails;
			DECLARE excpRef REFERENCE TO Environment.Variables.ExceptionDetails;
			DECLARE exceptionTxt CHARACTER excpRef.excpText;
			CALL writeToLogFile(MessageFlowLabel,LOGGER_NAME,LOG_TYPE,'Exception Type:'||outRef.excpType) INTO rc;
			CALL writeToLogFile(MessageFlowLabel,LOGGER_NAME,LOG_TYPE,'Exception Text:'||outRef.excpText) INTO rc;
			CALL writeToLogFile(MessageFlowLabel,LOGGER_NAME,LOG_TYPE,'..............end of logging Exception...........') INTO rc;
			RETURN TRUE;
		ELSE
			--if InputExceptionList is not populated and terminal connected to exception handler library then return false.
			--it can occur if http node terminal timeout is connected to exception handler library.
			CALL writeToLogFile(MessageFlowLabel,LOGGER_NAME,LOG_TYPE,'Exception List is empty') INTO rc;
			CALL writeToLogFile(MessageFlowLabel,LOGGER_NAME,LOG_TYPE,'..............end of logging Exception...........') INTO rc;
			RETURN FALSE;
		END IF;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE getExceptionDesc(IN excpRef REFERENCE,IN insertRef REFERENCE,INOUT outRef REFERENCE,IN domainName CHAR)
	BEGIN
		CREATE LASTCHILD OF outRef AS outRef DOMAIN domainName;
		CREATE LASTCHILD OF outRef AS outRef NAME 'ExceptionDetails';
		CREATE LASTCHILD OF outRef NAME 'excpType';
		CREATE LASTCHILD OF outRef NAME 'excpNumber';
		CREATE LASTCHILD OF outRef NAME 'excpLable';
		CREATE LASTCHILD OF outRef NAME 'excpMessage';
		CREATE LASTCHILD OF outRef NAME 'excpDescription';
		DECLARE messageText,lastExcpText CHARACTER '';
		DECLARE exceptionName CHARACTER '';
		DECLARE timoutField REFERENCE TO InputLocalEnvironment;
		DECLARE FlowName,ServiceName,NodeName CHAR;
		CALL getFlowDetails(excpRef,FlowName,NodeName);
		SET outRef.FlowName = SUBSTRING(SUBSTRING(FlowName AFTER '.')AFTER '.');
		SET ServiceName = SUBSTRING(SUBSTRING(SUBSTRING(FlowName AFTER '.')AFTER '.')BEFORE '_');
		SET outRef.ServiceName = ServiceName;
		SET outRef.ApplicationName = 'DashenBank_'||ServiceName||'_App';
		SET outRef.NodeName = SUBSTRING(SUBSTRING(NodeName AFTER '_') AFTER '.');
		WHILE LASTMOVE(excpRef) DO
			IF excpRef.Number IS NOT NULL THEN
				SET outRef.excpType = FIELDNAME(excpRef);
				SET exceptionName = FIELDNAME(excpRef);
				SET outRef.excpNumber = excpRef.Number;
				SET outRef.excpLable = excpRef.Label;
				IF stringValidation(excpRef.Text) THEN
					SET messageText = messageText||','||excpRef.Text;
				END IF;
				--- fetch description from Insert[]
				MOVE insertRef TO excpRef.Insert[>];
				WHILE LASTMOVE(insertRef) AND FIELDNAME(insertRef) = 'Insert' DO
					IF NOT LENGTH(insertRef.Text) = 1 AND
						stringValidation(insertRef.Text)THEN
						SET messageText = messageText||','||insertRef.Text;
						SET lastExcpText = insertRef.Text ;
					END IF;
					MOVE insertRef NEXTSIBLING;
				END WHILE;
			END IF;
			MOVE excpRef LASTCHILD;
		END WHILE;
		SET outRef.excpDescription = exceptionName||''||OVERLAY(messageText PLACING ':' FROM 1 FOR 1);
		SET outRef.excpMessage = lastExcpText;
		IF FIELDNAME(timoutField.HTTP.Input.Timeout) IS NOT NULL OR FIELDNAME(timoutField.SOAP.Input.Timeout) IS NOT NULL THEN
			SET outRef.excpDescription = TIMEOUT_ERROR_MSG ||CAST(timoutField.HTTP.Input.Timeout.OriginalClientWaitTime AS CHARACTER)||' seconds).';
		END IF;
	END;
	CREATE PROCEDURE stringValidation (IN text CHARACTER)
	RETURNS BOOLEAN
	BEGIN
		IF NOT CONTAINS(text, 'Node throwing exception') AND
			NOT CONTAINS(text, 'Caught exception and rethrowing') AND
			NOT CONTAINS(text, 'Error detected, rethrowing') AND
			NOT CONTAINS(text, 'Error occured in procedure') AND
			NOT LENGTH(text) = 1 THEN
			RETURN TRUE;
		ELSE
			RETURN FALSE;
		END IF;
	END;

	CREATE PROCEDURE getFlowDetails(IN excListRef REFERENCE , INOUT FlowName CHAR,INOUT NodeName CHAR)
	BEGIN
		--Taking messge flow details
		--Taking message flow name , node name
		DECLARE label CHARACTER;
		DECLARE flowNameone,flowNametwo CHARACTER;
		DECLARE fieldPosition INTEGER;
		SET label = excListRef.Label;
		SET flowNameone = excListRef.Name;
		SET fieldPosition = POSITION('.' IN label);
		SET flowNametwo = SUBSTRING(flowNameone AFTER '.');
		IF flowNametwo = '' THEN
			SET FlowName = SUBSTRING(flowNameone BEFORE '#');
		ELSE
			SET FlowName = SUBSTRING(flowNametwo BEFORE '#');
		END IF;
		SET NodeName = SUBSTRING(label FROM (fieldPosition+1));
	END;
END MODULE;